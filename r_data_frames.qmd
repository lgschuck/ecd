# Data Frames

[Status](convencoes.html#status-do-material) üü¶üü¶üü¶

## O que s√£o data frames ?

Conforme o @r_language_definition, **data frame** √© a estrutura que imita de forma mais pr√≥xima um dataset do **SAS** ou **SPSS**. De forma resumida um **data frame** √© uma estrutura tabular com colunas (vari√°veis, atributos, etc) e linhas (registros, casos, observa√ß√µes, inst√¢ncias, etc). Diferente de uma matriz um **data frame** pode ter diferentes tipos de dados em suas colunas.

Um **data frame** possui todas as colunas com o mesmo tamanho (quantidade de regitros). A classe de um objeto **data frame** possui o nome **data.frame**. Abaixo pode ser visualizada a classe do **data frame** [iris](https://archive.ics.uci.edu/ml/datasets/iris) (muito usado em exemplos em Ci√™ncia de Dados) e tamb√©m as primeiras linhas com o comando `head`.

```{r}
class(iris)
head(iris)
```

Um **data frame** √© na verdade uma **lista**, assim as opera√ß√µes efetuadas em **listas** possuem equival√™ncia em **data frames**.

```{r}
typeof(iris)
```

### Criando Data Frames

Objetos da classe **data.frame** podem ser criados com a fun√ß√£o `data.frame`.

Aqui ser√£o usadas as conven√ß√µes de nomes conforme cap√≠tulos [Nomeando Objetos](nomes.html) e [Conven√ß√µes](convencoes.html).

```{r}
df_exemplo <- data.frame(
  VAR_A = c(1:5),
  VAR_B = c(101:105)
)
df_exemplo
```

### Aplicar conven√ß√µes de nomes

Para continuar os pr√≥ximos t√≥picos vamos trabalhar com um **data frame** (**df_iris**) criado a partir do **data frame** **iris**. Faremos ajustes nos nomes deste data frame.

```{r}
# criar data frame df_iris
df_iris <- iris
# mudar nomes para maiusculas
names(df_iris) <- toupper(names(df_iris))
# substituir '.' por '_'
names(df_iris) <- gsub(names(df_iris), pattern = "\\.", replacement = "_")  

class(df_iris)
head(df_iris)

```

## Atributos

Os atributos "padr√£o" de um **data frame** s√£o: `names`, `class` e `row.names`. √â poss√≠vel acess√°-los com a fun√ß√£o `attributes`. O atributo `names` tamb√©m pode ser obtido com a fun√ß√£o `names`.

```{r}
attributes(df_iris)
names(df_iris)
```

## Dimens√µes

A fun√ß√£o `dim` retorna as dimens√µes de um **data frame** (linhas e colunas). Estes dados tamb√©m podem ser obtidos com as fun√ß√µes `nrow` e `ncol`.

```{r}
dim(df_iris)
nrow(df_iris)
ncol(df_iris)
```

## Acessando Dados

### √çndices

Como a estrutura de um **data frame** √© organizada em linhas e colunas, podemos acessar os dados utilizando colchetes (`[ ]`): base\[linha, coluna\]. Podem ser usados intervalos de √≠ndices com o operador `:`.

```{r}
# Acessar primeira linha e segunda coluna (Sepal.Width)
df_iris[1, 2]
# Acessar linhas 1 at√© 3 e a segunda coluna
df_iris[1:3, 2]
```

Apesar de ser poss√≠vel, utilizar o √≠ndice faz com que a refer√™ncia seja relativa, ou seja, a vari√°vel '1' pode mudar caso o **data frame** seja editado. Por exemplo, caso em algum momento anterior a vari√°vel **PETAL_LENGTH** tenha sido exclu√≠da, uma nova vari√°vel assumir√° o √≠ndice 1. Al√©m disto, no momento da leitura do c√≥digo por um usu√°rio n√£o fica claro qual vari√°vel est√° sendo acessada.

### Usando Nomes das Colunas

Existem diversas outras formas para acessar dados de um **data frame**, inclusive utilizando o nome da coluna de forma expl√≠cita.

```{r}
# Acessar primeira linha e segunda coluna (pelo nome)
df_iris[1:3, 'SEPAL_WIDTH']

```

Uma forma bastante comum √© atrav√©s da utiliza√ß√£o do operador `$` para acessar a coluna pelo seu nome.

```{r}
# Acessar primeira linha e segunda coluna
df_iris[1, ]$SEPAL_WIDTH
# Acessar linhas 1 at√© 3 e a segunda coluna
df_iris[1:3, ]$SEPAL_WIDTH
```

::: callout-tip
## Nome Abreviado

Assim como nas **listas,** vari√°veis de um **data frame** podem ser acessadas com o m√≠nimo de caracteres que as identifiquem dentro do **data frame**. Por exemplo, `df_iris$SP` retornar√° a vari√°vel **SPECIES.**
:::

### Filtrando Dados

Digamos que se deseje acessar apenas dados que cumpram determinada condi√ß√£o. Para isto, na sele√ß√£o das linhas do **data frame**, deve ser informada condi√ß√£o l√≥gica na forma abaixo:

```{r}
# Retorna valores de Speal.Width onde Petal.Length for maior do que 6
x <- df_iris[df_iris$PETAL_LENGTH > 6, 'SEPAL_WIDTH']
y <- df_iris[df_iris$PETAL_LENGTH > 6.5, ]$SEPAL_WIDTH

x
y
# Fun√ß√£o que compara os objetos
identical(x, y)
```

O retorno √© dado pelas linhas em que a vari√°vel **PETAL_LENGTH** atende as condi√ß√µes declaradas. Este teste retorna um vetor de valores l√≥gicos, e os valores `TRUE` s√£o os que "permanecem". Abaixo outro exemplo:

```{r}
head(df_iris$PETAL_LENGTH) > 1.4
```

Aplicando este vetor de valores l√≥gicos, o R entende que as posi√ß√µes correspondentes a `TRUE` devem ser mantidas. No exemplo abaixo, as posi√ß√µes (linhas) 4 e 6 atendem a condi√ß√£o especificada, portanto apenas estas ser√£o selecionadas.

```{r}
df_iris2 <- head(df_iris)
filtro <- head(df_iris2$PETAL_LENGTH) > 1.4
filtro
df_iris2[filtro, 'SEPAL_WIDTH']
```

Equivalente ao comando abaixo:

```{r}
df_iris2[c(4, 6), 'SEPAL_WIDTH']
```

#### Classes de retorno

Os filtros em **data frames** usados com `$` ou `[ ]` (com apenas 1 vari√°vel) retornam vetores e n√£o **data frames**. Desta forma se perde a classe e a estrutura tabular caracter√≠stica do **data frame** original.

```{r}
class(df_iris[1:3, 1])
class(df_iris[1:3, 'SEPAL_WIDTH'])
```

Entretanto, sendo selecionadas mais de uma coluna, a classe retornada segue sendo **data.frame**.

```{r}

class(df_iris[1:3, c("SEPAL_LENGTH", "SEPAL_WIDTH")])
class(df_iris[1:3, 1:2])
```

#### Fun√ß√£o Subset

A fun√ß√£o `subset` permite efetuar filtro em um **data frame** e muitas vezes oferece uma forma mais organizada visualmente, principalmente quando em filtros com muitas condi√µes. Uma outra vantagem √© que a fun√ß√£o subset retorna faz a sele√ß√£o em um data.frame e retorna um **data frame**, mesmo com a sele√ß√£o de apenas 1 vari√°vel.

Esta fun√ß√£o tamb√©m permite sele√ß√£o de colunas a serem mantidas. Note que a fun√ß√£o subset n√£o demanda que o **data frame** seja referenciado antes das vari√°veis e tamb√©m aceita os nomes das vari√°veis sem aspas. Isto torna o c√≥digo mais leg√≠vel.

```{r}
class(subset(df_iris, select = SEPAL_WIDTH))
```

```{r}
df_mtcars <- mtcars
# mudar nomes para maiusculas
names(df_mtcars) <- toupper(names(df_mtcars))

subset(x = df_mtcars, # dados
       subset = MPG > 25, # filtro  
       select = c(MPG, CYL, HP)) # colunas
```

Usando um filtro um pouco mais complexo e sem inserir o nome dos argumentos da fun√ß√£o (`x`, `subset` e `select)`:

```{r}
df_mtcars_filtrado <- subset(df_mtcars, # dados 
       MPG > 25 & CYL == 4 & HP > 70, # filtro  
       c(MPG, CYL, HP)) # colunas

df_mtcars_filtrado
```

## Jun√ß√£o de Dados

Uma grande necessidade ao se trablahar com dados tabulados √© a jun√ß√£o de dados. A jun√ß√£o nada mais √© do que usar bases de dados diferentes e carregar dados entre elas a partir de uma chave de identifica√ß√£o. Vamos usar duas bases de dados, uma com c√≥digo e nome do munic√≠pio e outra com o c√≥digo do munic√≠pio e sua popula√ß√£o. Estes dados foram buscados em @ibge_cidades.

```{r}

df_cidades <-
  data.frame(
    COD_MUNICIPIO = c('4314902', '3550308', '3304557'),
    NOME = c('Porto Alegre', 'S√£o Paulo', 'Rio de Janeiro')
  )
                        
df_populacao <-
  data.frame(
    COD_MUNICIPIO = c('4314902', '3550308', '3304557'),
    POPULACAO = c(1332570, 11451245, 6211423)
  )

head(df_cidades)
head(df_populacao)

```

Para juntar estes dados, usaremos como chave de identifica√ß√£o presente nas duas tabelas o campo **COD_MUNICIPIO**. A fun√ß√£o usada, `merge` exige dois argumentos **x** e **y**, que s√£o as bases de dados que usaremos para a jun√ß√£o.

```{r}
df_completo <- merge(x = df_cidades, y = df_populacao,
                     by = "COD_MUNICIPIO")

head(df_completo)
```

Este exemplo √© o mais b√°sico, onde os dados presentes em ambas tabelas s√£o das mesmas ciades e tamb√©m s√£o ligadas por apenas uma chave de identifica√ß√£o. Vejamos um exemplo um pouco mais realista, onde alguns dados n√£o est√£o presentes em ambas tabelas.

```{r}

# rbind faz a inclusao de linha nas as bases criadas
df_cidades <- rbind(df_cidades, c('3106200', 'Belo Horizonte'))
df_populacao <- rbind(df_populacao, c('4106902', 1773733))

df_completo <- merge(x = df_cidades, y = df_populacao,
                     by = "COD_MUNICIPIO")

head(df_completo)

```

Veja que os dados de Belo Horizonte e do Munic√≠pio de c√≥digo 4106902 (Curitiba) n√£o foram inseridos no data frame resultante. Por padr√£o a fun√ß√£o `merge` faz a jun√ß√£o pelos dados presentes nos dois data frames. Caso desejemos especificar, usamos os par√¢metros `all.x` e `all.y`.

Usando `all.x` informamos ao R que desejamos que todas as linhas presentes na base passada como argumento x sejam mantidas. Onde n√£o existirem dados para estas linhas na tabela y ser√£o preenchidos com `NA`.

```{r}

df_completo_x <- merge(x = df_cidades, y = df_populacao,
                     by = "COD_MUNICIPIO", all.x = T)

head(df_completo_x)

```

De forma an√°loga, usar `all.y` informa para que as linhas da base y sejam mantidas.

```{r}
df_completo_y <- merge(x = df_cidades, y = df_populacao,
                     by = "COD_MUNICIPIO", all.y = T)

head(df_completo_y)

```

Para cruzamento de todas as linhas das duas tabelas usamos o argumento `all`.

```{r}
df_completo <- merge(x = df_cidades, y = df_populacao,
                     by = "COD_MUNICIPIO", all = T)

head(df_completo)
```

------------------------------------------------------------------------

√öltima atualiza√ß√£o: `r format(file.info('r_data_frames.qmd')$mtime, '%d/%m/%Y - %H:%M:%S')`
